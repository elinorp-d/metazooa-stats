<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Metazooa Head-to-Head: Elinor vs Yasha</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>  <style>
    body { font-family: system-ui,sans-serif; max-width: 900px; margin: 30px auto; }
    h1, h2 { text-align: center; }
    .flex-row {
      display: flex;
      gap: 20px;
      margin-bottom: 12px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .flex-col {
      display: flex;
      flex-direction: column;
      flex: 1;
      min-width: 260px;
      max-width: 400px;
    }
    textarea { width: 100%; height: 70px; font-size: 1em; margin-bottom: 8px; }
    label { font-weight: bold; margin-bottom: 4px;}
    button { margin-top: 10px; font-size: 1em; }
    .winner { font-size: 1.1em; margin: 10px 0; font-weight: bold; }
    table { border-collapse: collapse; width: 100%; margin-top: 22px;}
    th, td { border: 1px solid #ccc; padding: 4px 8px; text-align: center;}
    th { background: #f2f2f2; }
    .el { color: #13b34a; font-weight: bold; }
    .ya { color: #8a37d7; font-weight: bold; }
    .tie { color: #555; }
    .box { background: #fafbfc; border-radius: 12px; padding: 18px; margin-top: 15px; box-shadow: 0 1px 4px #ddd;}
    .action-links a { cursor:pointer; color:#8a37d7; text-decoration:underline; margin:0 3px;}
    .action-links a.delete { color:#b96c12;}
    .action-links a:visited { color:#8a37d7;}
    .action-links a.delete:visited { color:#b96c12;}
    .editArea { width:95%; height:40px; font-size:0.97em;}
    .charts-flex {
      display: flex;
      gap: 28px;
      justify-content: center;
      align-items: flex-end;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }
    .chart-container { width: 230px; min-width: 180px;}
    .play-button {
      display: inline-block;
      background-color: #4a90e2;
      color: white;
      padding: 8px 16px;
      border-radius: 4px;
      text-decoration: none;
      font-weight: bold;
      margin-top: 0px;
    }
    .play-button:hover {
      background-color: #3a80d2;
    }
    @media (max-width: 900px) {
      .charts-flex { flex-direction: column; align-items: center;}
      .flex-row { flex-direction: column;}
    }
    @media (max-width: 600px) {
      .chart-container { width: 100%; min-width: 120px;}
      .stat { min-width: 120px;}
      table,th,td { font-size:0.95em;}
    }
  </style>
</head>
<body>
  <h1>Metazooa Head-to-Head</h1>
  <div style="text-align: center;">
    <a href="https://metazooa.com/play/game" target="_blank" class="play-button">Play here</a>
  </div>

  <div class="box">
    <form id="entryForm" autocomplete="off">
      <div class="flex-row">
        <div class="flex-col">
          <label class="el">Elinor's Metazooa Result:</label>
          <textarea id="elinorInput" placeholder="Paste Elinor's Metazooa result here"></textarea>
        </div>
        <div class="flex-col">
          <label class="ya">Yasha's Metazooa Result:</label>
          <textarea id="yashaInput" placeholder="Paste Yasha's Metazooa result here"></textarea>
        </div>
      </div>
      <button type="submit" class="btn">Add Today's Result</button>
    </form>
  </div>

  <div class="box" id="dashboard">
    <h3 style="margin-bottom:12px;"><span class="el">Elinor</span> vs <span class="ya">Yasha</span> Stats Dashboard</h3>
    <div class="charts-flex">
      <div class="chart-container">
        <canvas id="winChart"></canvas>
        <div style="text-align:center;margin-top:2px;font-weight:500;">Win %</div>
      </div>
      <!-- <div class="chart-container">
        <canvas id="solveChart"></canvas>
        <div style="text-align:center;margin-top:2px;font-weight:500;">Solve Rate</div>
      </div> -->
      <div class="chart-container">
        <canvas id="avgChart"></canvas>
        <div style="text-align:center;margin-top:2px;font-weight:500;">Avg # of Guesses</div>
      </div>
      <div class="chart-container">
        <canvas id="diffChart"></canvas>
        <div style="text-align:center;margin-top:2px;font-weight:500;">Avg Win Differential</div>
      </div>
    </div>
    <div style="text-align:center;margin-top:14px;">
      <span class="el">Elinor</span> Win %: <span id="elinorWin"></span> &nbsp; 
      <span class="ya">Yasha</span> Win %: <span id="yashaWin"></span> &nbsp; 
      Ties: <span id="ties"></span>
      <br>
    </div>
  </div>

  <div class="box">
    <h3>Results History</h3>
    <table id="historyTable">
      <thead>
        <tr>
          <th>Date</th>
          <th>Puzzle #</th>
          <th>Elinor</th>
          <th>Yasha</th>
          <th>Winner</th>
          <th>Reason</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        <!-- Data will appear here -->
      </tbody>
    </table>
    <div style="margin-top:15px;">
      <button class="btn" onclick="exportCSV()">Export CSV</button>
      <button class="btn" onclick="document.getElementById('importFile').click()">Import CSV</button>
      <input type="file" id="importFile" accept=".csv" />
    </div>
  </div>

  <script>
    // Chart.js chart instances
    let winChart, /*solveChart,*/ avgChart, diffChart;

    // Utilities to parse Metazooa pasted results
    function parseResult(text) {
      if (!text || text.length < 5) return null;
      let solved = text.includes('I figured it out');
      let guesses = solved
        ? Number((text.match(/in ([0-9]+) guesses!/)||[])[1] || 0)
        : 20;
      let puzzleNum = Number((text.match(/Animal #([0-9]+)/)||[])[1] || '');
      return { solved, guesses, puzzleNum, raw: text.trim() };
    }

    // Storage helpers
    function saveData(data) { localStorage.setItem('metazooaData', JSON.stringify(data)); }
    function loadData() { return JSON.parse(localStorage.getItem('metazooaData')||'[]'); }

    // Main state
    let results = loadData();
    render();

    document.getElementById('entryForm').onsubmit = function(e) {
      e.preventDefault();
      let elinorRaw = document.getElementById('elinorInput').value.trim();
      let yashaRaw = document.getElementById('yashaInput').value.trim();
      let eRes = parseResult(elinorRaw);
      let yRes = parseResult(yashaRaw);

      if (!eRes || !yRes) {
        alert('Both results must be pasted and look like Metazooa results.');
        return;
      }

      // Puzzle number/date (use puzzle # as date key, or fallback to today)
      let puzzleNum = eRes.puzzleNum || yRes.puzzleNum || '';
      let today = new Date().toISOString().slice(0,10);

      // Calculate winner & reason
      let winner = 'Tie', reason = '';
      if (eRes.solved && !yRes.solved) { winner = 'Elinor'; reason = 'Solved, opponent didn\'t.'; }
      else if (!eRes.solved && yRes.solved) { winner = 'Yasha'; reason = 'Solved, opponent didn\'t.'; }
      else if (eRes.solved && yRes.solved) {
        if (eRes.guesses < yRes.guesses) { winner = 'Elinor'; reason = 'Fewer guesses.'; }
        else if (eRes.guesses > yRes.guesses) { winner = 'Yasha'; reason = 'Fewer guesses.'; }
        else { winner = 'Tie'; reason = 'Same number of guesses.'; }
      }
      else { winner = 'Tie'; reason = 'Both stumped.'; }

      // Prevent duplicates by puzzleNum
      if (puzzleNum && results.some(r => r.puzzleNum == puzzleNum)) {
        if (!confirm("You've already entered results for this puzzle #. Add again?")) return;
      }

      results.push({
        date: today,
        puzzleNum,
        elinor: eRes,
        yasha: yRes,
        winner, reason
      });
      saveData(results);
      document.getElementById('elinorInput').value = '';
      document.getElementById('yashaInput').value = '';
      render();
    };

    function render() {
      // Win counts
      let elinorWins = 0, yashaWins = 0, ties = 0;
      let elinorSolves = 0, yashaSolves = 0;
      let elinorGuessTotal = 0, yashaGuessTotal = 0, count = 0;
      let elinorWinDiffs = [], yashaWinDiffs = [];
      
      // For standard deviation calculation
      let elinorGuesses = [], yashaGuesses = [];
      
      results.forEach(r => {
        if (r.winner === 'Elinor') {
          elinorWins++;
          // win diff = yasha.guesses - elinor.guesses (always positive)
          elinorWinDiffs.push((r.yasha.guesses || 0) - (r.elinor.guesses || 0));
        }
        else if (r.winner === 'Yasha') {
          yashaWins++;
          yashaWinDiffs.push((r.elinor.guesses || 0) - (r.yasha.guesses || 0));
        }
        else ties++;
        if (r.elinor.solved) elinorSolves++;
        if (r.yasha.solved) yashaSolves++;
        elinorGuessTotal += r.elinor.guesses || 0;
        yashaGuessTotal += r.yasha.guesses || 0;
        
        // Add guesses to arrays for standard deviation calculation
        elinorGuesses.push(r.elinor.guesses || 0);
        yashaGuesses.push(r.yasha.guesses || 0);
        
        count++;
      });
    
      let elinorWinPct = count ? (100*elinorWins/count) : 0;
      let yashaWinPct = count ? (100*yashaWins/count) : 0;
      let elinorSolvePct = count ? (100*elinorSolves/count) : 0;
      let yashaSolvePct = count ? (100*yashaSolves/count) : 0;
      let elinorAvg = count ? (elinorGuessTotal/count) : 0;
      let yashaAvg = count ? (yashaGuessTotal/count) : 0;
    
      // Calculate standard deviation
      let elinorGuessStdDev = calculateStdDev(elinorGuesses, elinorAvg);
      let yashaGuessStdDev = calculateStdDev(yashaGuesses, yashaAvg);
    
      // Average win differential for each player (positive, only over wins)
      let elinorAvgDiff = elinorWinDiffs.length ? (elinorWinDiffs.reduce((a,b)=>a+b,0)/elinorWinDiffs.length) : 0;
      let yashaAvgDiff = yashaWinDiffs.length ? (yashaWinDiffs.reduce((a,b)=>a+b,0)/yashaWinDiffs.length) : 0;

      // Calculate standard deviation for win differentials
      let elinorDiffStdDev = calculateStdDev(elinorWinDiffs, elinorAvgDiff);
      let yashaDiffStdDev = calculateStdDev(yashaWinDiffs, yashaAvgDiff);
    
      document.getElementById('elinorWin').textContent = count ? elinorWinPct.toFixed(1) + '%' : '--';
      document.getElementById('yashaWin').textContent = count ? yashaWinPct.toFixed(1) + '%' : '--';
      document.getElementById('ties').textContent = ties;
         
      // Log standard deviation values to the console
      console.log('Elinor Guess Standard Deviation:', elinorGuessStdDev);
      console.log('Yasha Guess Standard Deviation:', yashaGuessStdDev);
      console.log('Elinor Diff Standard Deviation:', elinorDiffStdDev);
      console.log('Yasha Diff Standard Deviation:', yashaDiffStdDev);

      // Table with Edit/Delete; date is editable as a textbox
      let rows = results.map((r, trueIndex) => ({...r, trueIndex}))
        .sort((a, b) => {
          // Sort by puzzle number (descending)
          const puzzleA = Number(a.puzzleNum) || 0;
          const puzzleB = Number(b.puzzleNum) || 0;
          return puzzleB - puzzleA;
        })
        .map((r, rowIdx) => {
          if (r._editing) {
            return `
            <tr>
              <td><input id="editDate${r.trueIndex}" type="text" value="${r.date}" style="width:110px;" /></td>
              <td>${r.puzzleNum||''}</td>
              <td><textarea id="editElinor${r.trueIndex}" class="editArea">${r.elinor.raw||''}</textarea></td>
              <td><textarea id="editYasha${r.trueIndex}" class="editArea">${r.yasha.raw||''}</textarea></td>
              <td colspan="3" class="action-links">
                <a href="#" onclick="saveEdit(${r.trueIndex});return false;">Save</a> |
                <a href="#" onclick="cancelEdit(${r.trueIndex});return false;">Cancel</a>
              </td>
            </tr>
            `;
          } else {
            return `
            <tr>
              <td>${r.date}</td>
              <td>${r.puzzleNum||''}</td>
              <td>
                ${r.elinor.solved ? '✅' : '❌'}<br>
                ${r.elinor.guesses} guesses
              </td>
              <td>
                ${r.yasha.solved ? '✅' : '❌'}<br>
                ${r.yasha.guesses} guesses
              </td>
              <td class="${r.winner==='Elinor'?'el':r.winner==='Yasha'?'ya':'tie'}">${r.winner}</td>
              <td>${r.reason}</td>
              <td class="action-links">
                <a href="#" onclick="editEntry(${r.trueIndex});return false;">Edit</a> |
                <a href="#" class="delete" onclick="deleteEntry(${r.trueIndex});return false;">Delete</a>
              </td>
            </tr>
            `;
          }
        }).join('');
      document.querySelector('#historyTable tbody').innerHTML = rows || '<tr><td colspan="7">No results yet.</td></tr>';

      updateCharts(elinorWinPct, yashaWinPct, ties, elinorSolvePct, yashaSolvePct, elinorAvg, yashaAvg, elinorAvgDiff, yashaAvgDiff, elinorGuessStdDev, yashaGuessStdDev, elinorDiffStdDev, yashaDiffStdDev);
    }
    // Add this helper function to calculate standard deviation
    function calculateStdDev(values, mean) {
      if (values.length === 0) return 0;
      
      // Calculate sum of squared differences from mean
      const squaredDiffs = values.map(value => Math.pow(value - mean, 2));
      const sumSquaredDiffs = squaredDiffs.reduce((sum, value) => sum + value, 0);
      
      // Calculate standard deviation
      return Math.sqrt(sumSquaredDiffs / values.length);
    }

    window.editEntry = function(trueIndex) {
      results[trueIndex]._editing = true;
      saveData(results);
      render();
    }
    window.cancelEdit = function(trueIndex) {
      delete results[trueIndex]._editing;
      render();
    }
    window.saveEdit = function(trueIndex) {
      let r = results[trueIndex];
      let dateText = document.getElementById('editDate'+trueIndex).value.trim();
      let elinorText = document.getElementById('editElinor'+trueIndex).value.trim();
      let yashaText = document.getElementById('editYasha'+trueIndex).value.trim();
      let eRes = parseResult(elinorText);
      let yRes = parseResult(yashaText);
      if (!eRes || !yRes) { alert('Please paste valid Metazooa results for both players.'); return; }
      let winner = 'Tie', reason = '';
      if (eRes.solved && !yRes.solved) { winner = 'Elinor'; reason = 'Solved, opponent didn\'t.'; }
      else if (!eRes.solved && yRes.solved) { winner = 'Yasha'; reason = 'Solved, opponent didn\'t.'; }
      else if (eRes.solved && yRes.solved) {
        if (eRes.guesses < yRes.guesses) { winner = 'Elinor'; reason = 'Fewer guesses.'; }
        else if (eRes.guesses > yRes.guesses) { winner = 'Yasha'; reason = 'Fewer guesses.'; }
        else { winner = 'Tie'; reason = 'Same number of guesses.'; }
      }
      else { winner = 'Tie'; reason = 'Both stumped.'; }
      r.date = dateText;
      r.elinor = eRes; r.yasha = yRes;
      r.elinor.raw = elinorText; r.yasha.raw = yashaText;
      r.puzzleNum = eRes.puzzleNum || yRes.puzzleNum || r.puzzleNum;
      r.winner = winner; r.reason = reason;
      delete r._editing;
      saveData(results);
      render();
    }
    window.deleteEntry = function(trueIndex) {
      if (!confirm('Delete this result? This cannot be undone.')) return;
      results.splice(trueIndex, 1);
      saveData(results);
      render();
    }

    // CSV Export/Import
    function exportCSV() {
      const header = ['date','puzzleNum',
        'elinorSolved','elinorGuesses',
        'yashaSolved','yashaGuesses',
        'winner','reason'
      ];
      const rows = results.map(r=>[
        r.date, r.puzzleNum,
        r.elinor.solved, r.elinor.guesses,
        r.yasha.solved, r.yasha.guesses,
        r.winner, r.reason.replace(/,/g, ';')
      ]);
      let csv = [header.join(',')].concat(rows.map(r=>r.join(','))).join('\n');
      let blob = new Blob([csv], {type:'text/csv'});
      let link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'metazooa_elinor_yasha.csv';
      link.click();
    }

    document.getElementById('importFile').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      let reader = new FileReader();
      reader.onload = function(evt) {
        let text = evt.target.result;
        let lines = text.split(/\r?\n/);
        let header = lines.shift().split(',');
        let idx = {};
        header.forEach((h,i)=>{idx[h]=i});
        let imported = [];
        lines.forEach(line=>{
          if (!line.trim()) return;
          let parts = line.split(',');
          imported.push({
            date: parts[idx['date']],
            puzzleNum: parts[idx['puzzleNum']],
            elinor: {
              solved: parts[idx['elinorSolved']]==='true',
              guesses: Number(parts[idx['elinorGuesses']])
            },
            yasha: {
              solved: parts[idx['yashaSolved']]==='true',
              guesses: Number(parts[idx['yashaGuesses']])
            },
            winner: parts[idx['winner']],
            reason: parts[idx['reason']].replace(/;/g,',')
          });
        });
        results = imported;
        saveData(results);
        render();
        alert('Import complete! Your data has been loaded.');
        e.target.value = '';
      };
      reader.readAsText(file);
    });

    function updateCharts(elinorWinPct, yashaWinPct, ties, elinorSolve, yashaSolve, elinorAvg, yashaAvg, elinorAvgDiff, yashaAvgDiff, elinorGuessStdDev, yashaGuessStdDev, elinorDiffStdDev, yashaDiffStdDev) {
      let elColor = '#13b34a', yaColor = '#8a37d7', tieColor = '#d4d4d4';
      // Win chart (Pie)
      let pieData = {
        labels: ['Elinor', 'Yasha', 'Ties'],
        datasets: [{
          data: [elinorWinPct, yashaWinPct, ties ? (100-elinorWinPct-yashaWinPct) : 0],
          backgroundColor: [elColor, yaColor, tieColor]
        }]
      };
      if (!winChart) {
        winChart = new Chart(document.getElementById('winChart').getContext('2d'), {
          type: 'pie',
          data: pieData,
          options: { responsive:true, plugins:{legend:{display:true,position:'bottom'}} }
        });
      } else {
        winChart.data = pieData;
        winChart.update();
      }
      // Solve rate (Bar)
      /*
      let barData = {
        labels: ['Elinor', 'Yasha'],
        datasets: [{
          label: 'Solve Rate (%)',
          data: [elinorSolve, yashaSolve],
          backgroundColor: [elColor, yaColor],
          borderRadius: 6,
        }]
      };
      if (!solveChart) {
        solveChart = new Chart(document.getElementById('solveChart').getContext('2d'), {
          type: 'bar',
          data: barData,
          options: { 
            responsive:true,
            scales: { y: { min:0, max:100, ticks:{stepSize:20}}},
            plugins:{legend:{display:false}}
          }
        });
      } else {
        solveChart.data = barData;
        solveChart.update();
      }
      */
      // Avg # Guesses (Bar)
      let avgBar = {
        labels: ['Elinor', 'Yasha'],
        datasets: [{
          label: 'Avg # Guesses',
          data: [elinorAvg, yashaAvg],
          backgroundColor: [elColor, yaColor],
          borderRadius: 6,
          errorBars: {
            // Add error bars as a custom property
            yMin: [elinorAvg - elinorGuessStdDev, yashaAvg - yashaGuessStdDev],
            yMax: [elinorAvg + elinorGuessStdDev, yashaAvg + yashaGuessStdDev]
          }    
        }]
      };
      if (!avgChart) {
        avgChart = new Chart(document.getElementById('avgChart').getContext('2d'), {
          type: 'bar',
          data: avgBar,
          options: { 
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 0.75,
            scales: { y: { min:0, max:20, ticks:{stepSize:5}}},
            plugins: {
              legend: {display: false},
              datalabels: {
                color: '#fff',
                formatter: function(value) {
                  return value.toFixed(2);
                },
                font: {
                  weight: 'bold'
                },
                // Use these settings for positioning
                position: 'chartArea', // Position relative to chart area
                anchor: 'start', // Center horizontally
                align: 'bottom', // Align to bottom
                clamp: true, // Prevent labels from going outside chart
                offset: function(context) {
                  // Get chart height and calculate offset to position above x-axis
                  const chartHeight = context.chart.height;
                  return -chartHeight * 0.065; // offset by % of chart height from bottom
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const dataset = context.dataset;
                    const index = context.dataIndex;
                    const value = dataset.data[index];
                    const min = dataset.errorBars.yMin[index];
                    const max = dataset.errorBars.yMax[index];
                    return `Avg: ${value.toFixed(2)} (±${dataset.errorBars.yMax[index] - value.toFixed(2)})`;
                  }
                }
              }    
            }
          },
          plugins: [ChartDataLabels, {
            id: 'errorBars',
            afterDraw: function(chart) {
              const ctx = chart.ctx;
              ctx.save();
              
              // Only apply to bar charts
              if (chart.config.type !== 'bar') {
                ctx.restore();
                return;
              }
              
              // Draw error bars
              chart.data.datasets.forEach((dataset, i) => {
                if (!dataset.errorBars) return;
                
                const meta = chart.getDatasetMeta(i);
                
                meta.data.forEach((bar, index) => {
                  const yMin = dataset.errorBars.yMin[index];
                  const yMax = dataset.errorBars.yMax[index];
                  
                  if (yMin === undefined || yMax === undefined) return;
                  
                  const { x } = bar.getCenterPoint();
                  const yScale = chart.scales.y;
                  const yMinPixel = yScale.getPixelForValue(yMin);
                  const yMaxPixel = yScale.getPixelForValue(yMax);
                  const barWidth = bar.width / 3; // Adjust error bar width
                  
                  // Draw the error line
                  ctx.beginPath();
                  ctx.lineWidth = 2;
                  ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                  ctx.moveTo(x, yMinPixel);
                  ctx.lineTo(x, yMaxPixel);
                  ctx.stroke();
                  
                  // Draw the top and bottom caps
                  ctx.beginPath();
                  ctx.moveTo(x - barWidth / 2, yMinPixel);
                  ctx.lineTo(x + barWidth / 2, yMinPixel);
                  ctx.moveTo(x - barWidth / 2, yMaxPixel);
                  ctx.lineTo(x + barWidth / 2, yMaxPixel);
                  ctx.stroke();
                });
              });
              
              ctx.restore();
            }
          }]
        });
      } else {
        avgChart.data = avgBar;
        avgChart.update();
      }
      // Win Differential
      let diffBar = {
        labels: ['Elinor', 'Yasha'],
        datasets: [{
          label: 'Avg Win Differential',
          data: [elinorAvgDiff, yashaAvgDiff],
          backgroundColor: [elColor, yaColor],
          borderRadius: 6,
          errorBars: {
            // Add error bars as a custom property
            yMin: [elinorAvgDiff - elinorDiffStdDev, yashaAvgDiff - yashaDiffStdDev],
            yMax: [elinorAvgDiff + elinorDiffStdDev, yashaAvgDiff + yashaDiffStdDev]
          }
        }]
      };
      if (!diffChart) {
        diffChart = new Chart(document.getElementById('diffChart').getContext('2d'), {
          type: 'bar',
          data: diffBar,
          options: { 
            responsive: true,
            maintainAspectRatio: true,
            aspectRatio: 0.75,
            scales: { y: { min:0, max:20, ticks:{stepSize:2}}},
            plugins: {
              legend: {display: false},
              datalabels: {
                color: '#fff',
                formatter: function(value) {
                  return value.toFixed(2);
                },
                font: {
                  weight: 'bold'
                },
                // Use these settings for positioning
                position: 'chartArea', // Position relative to chart area
                anchor: 'start', // Center horizontally
                align: 'bottom', // Align to bottom
                clamp: true, // Prevent labels from going outside chart
                offset: function(context) {
                  // Get chart height and calculate offset to position above x-axis
                  const chartHeight = context.chart.height;
                  return -chartHeight * 0.065; // offset by % of chart height from bottom
                }
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const dataset = context.dataset;
                    const index = context.dataIndex;
                    const value = dataset.data[index];
                    const min = dataset.errorBars.yMin[index];
                    const max = dataset.errorBars.yMax[index];
                    return `Avg: ${value.toFixed(2)} (±${(dataset.errorBars.yMax[index] - value).toFixed(2)})`;
                  }
                }
              }
            }
          },
          plugins: [ChartDataLabels, {
            id: 'errorBars',
            afterDraw: function(chart) {
              const ctx = chart.ctx;
              ctx.save();
              
              // Only apply to bar charts
              if (chart.config.type !== 'bar') {
                ctx.restore();
                return;
              }
              
              // Draw error bars
              chart.data.datasets.forEach((dataset, i) => {
                if (!dataset.errorBars) return;
                
                const meta = chart.getDatasetMeta(i);
                
                meta.data.forEach((bar, index) => {
                  const yMin = dataset.errorBars.yMin[index];
                  const yMax = dataset.errorBars.yMax[index];
                  
                  if (yMin === undefined || yMax === undefined) return;
                  
                  const { x } = bar.getCenterPoint();
                  const yScale = chart.scales.y;
                  const yMinPixel = yScale.getPixelForValue(yMin);
                  const yMaxPixel = yScale.getPixelForValue(yMax);
                  const barWidth = bar.width / 3; // Adjust error bar width
                  
                  // Draw the error line
                  ctx.beginPath();
                  ctx.lineWidth = 2;
                  ctx.strokeStyle = 'rgba(0, 0, 0, 0.6)';
                  ctx.moveTo(x, yMinPixel);
                  ctx.lineTo(x, yMaxPixel);
                  ctx.stroke();
                  
                  // Draw the top and bottom caps
                  ctx.beginPath();
                  ctx.moveTo(x - barWidth / 2, yMinPixel);
                  ctx.lineTo(x + barWidth / 2, yMinPixel);
                  ctx.moveTo(x - barWidth / 2, yMaxPixel);
                  ctx.lineTo(x + barWidth / 2, yMaxPixel);
                  ctx.stroke();
                });
              });
              
              ctx.restore();
            }
          }]
        });
      } else {
        diffChart.data = diffBar;
        diffChart.update();
      }
    }
  </script>
</body>
</html>
